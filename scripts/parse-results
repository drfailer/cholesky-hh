#!/usr/bin/env python3

import numpy as np
import matplotlib.pyplot as plt
import os

################################################################################
#                                   Measure                                    #
################################################################################

class Measure:
    def __init__(self, size):
        self.size = size
        self.times = []

    def add_time(self, time):
        self.times.append(time)

    def std(self):
        return np.std(self.times)

    def mean(self):
        return np.mean(self.times)


class MeasureLapack(Measure):
    def __init__(self, size, threads):
        Measure.__init__(self, size)
        self.threads = threads


class MeasureHH(Measure):
    def __init__(self, size, block_size, dThreads, cThreads, uThreads, sThreads, vThreads):
        Measure.__init__(self, size)
        self.block_size = block_size
        self.dThreads = dThreads
        self.cThreads = cThreads
        self.uThreads = uThreads
        self.sThreads = sThreads
        self.vThreads = vThreads

    def threads(self):
        return f"{self.dThreads}, {self.cThreads}, {self.uThreads}, {self.sThreads}, {self.vThreads}"

    def present(self):
        return f"""
Matrix size: {self.size} ({self.block_size})
- threads: d = {self.dThreads}, c = {self.cThreads}, u = {self.uThreads}, s = {self.sThreads}, v = {self.vThreads}
- time: {self.mean()}ms +- {self.std()}ms
"""


################################################################################
#                            parsing times.txt file                            #
################################################################################

# will contain all the hh_measures
hh_measures = dict()
lapack_measures = dict()
sizes_list = set()
block_sizes_list = set()
threads_list = set()


def parse_choleksy_hh_cmd(cmd):
    args = cmd.split(' ')

    size = int(args[4].split('/')[-1].split('.')[0])
    dThreads = int(args[6])
    cThreads = int(args[8])
    uThreads = int(args[10])
    sThreads = int(args[12])
    vThreads = int(args[14])
    block_size = int(args[16])
    return MeasureHH(size, block_size, dThreads, cThreads, uThreads, sThreads,
                     vThreads)


def parse_measure_hh(line, size, threads, block_size):
    line = line.strip()
    if line[-2:] == "ms":
        time = int(line[:-2])
        hh_measures[size][threads][block_size].add_time(time)
    else:
        measure = parse_choleksy_hh_cmd(line)
        size = measure.size
        if not size in hh_measures.keys():
            hh_measures[size] = dict()
        if not threads in hh_measures[size].keys():
            hh_measures[size][threads] = dict()
        sizes_list.add(size)
        block_sizes_list.add(block_size)
        threads_list.add(threads)
        hh_measures[size][threads][block_size] = measure

    return size


def parse_time_file(result_dir, threads_dir, block_dir):
    path = f"{result_dir}/{threads_dir}/{block_dir}/times.txt"
    size = 0
    threads = threads_dir
    block_size = int(block_dir)
    with open(path, "r") as file:
        for line in file:
            size = parse_measure_hh(line, size, threads, block_size)


################################################################################
#                            parse result directory                            #
################################################################################


def parse_threads_results(result_dir, threads_dir):
    dirs = os.listdir(f"{result_dir}/{threads_dir}")

    for block_dir in dirs:
        parse_time_file(result_dir, threads_dir, block_dir)


def parse_results_hh(result_dir):
    dirs = os.listdir(result_dir)
    dirs.remove("cpuinfo.txt")

    for threads_dir in dirs:
        parse_threads_results(result_dir, threads_dir)


def parse_times_lapack(threads, filename):
    size = int(filename.split('/')[-1][6: -4])

    if not size in lapack_measures:
        lapack_measures[size] = dict()
    lapack_measures[size][threads] = MeasureLapack(size, threads)
    with open(filename, "r") as file:
        for line in file:
            time = int(line[:-3])
            lapack_measures[size][threads].add_time(time)


def parse_threads_lapack(result_dir, threads_dir):
    for file in os.listdir(f"{result_dir}/{threads_dir}"):
        parse_times_lapack(int(threads_dir), f"{result_dir}/{threads_dir}/{file}")


def parse_results_lapack(result_dir):
    for threads_dir in os.listdir(result_dir):
        parse_threads_lapack(result_dir, threads_dir)


################################################################################
#                               generate report                                #
################################################################################

def hh_best_measure(size):
    result = MeasureHH(0, 0, 0, 0, 0, 0, 0)

    for threads_values in hh_measures[size].values():
        for measure in threads_values.values():
            if result.size == 0 or measure.mean() < result.mean():
                result = measure

    return result


def lapack_best_measure(size):
    result = MeasureLapack(0, 0)

    for measure in lapack_measures[size].values():
        if result.size == 0 or measure.mean() < result.mean():
            result = measure

    return result


def generate_report_blocks(file, threads_measures):
    for block_size in block_sizes_list:
        file.write(f" {threads_measures[block_size].mean()}ms +- {'%.3f' % threads_measures[block_size].std()}ms |")
    file.write("\n")


def generate_report_threads(file, size):
    file.write("| threads / block sizes_list |")
    for block_size in block_sizes_list:
        file.write(f" {block_size} |")
    file.write("\n")

    file.write("|")
    for _ in range(0, len(block_sizes_list) + 1):
        file.write(f"---|")
    file.write("\n")

    for threads in threads_list:
        file.write(f"| {threads} |")
        generate_report_blocks(file, hh_measures[size][threads])
    file.write("\n")

    best_hh = hh_best_measure(size)
    file.write(f"Best HH: threads = {best_hh.threads()}, block_size {best_hh.block_size}: {best_hh.mean()}\n")
    if size in lapack_measures.keys():
        best_lapack = lapack_best_measure(size)
        file.write(f"Best Lapack: threads = {best_lapack.threads}: {best_lapack.mean()}\n")
        file.write(f"Speedup max: {best_lapack.mean() / best_hh.mean()}\n\n")


def generate_hh_report(filename):
    with open(filename, "w+") as file:
        file.write(f"# Cholesky Hedgehog\n\n")
        for size in sizes_list:
            file.write(f"## Computation times depending on threads repartition and block size for a {size}x{size} matrix\n\n")
            generate_report_threads(file, size)


################################################################################
#                                generate plots                                #
################################################################################

def create_plot(x, datas, xlabel, ylabel, title, legend=True, std=False,
                filename=""):
    for label, values in datas.items():
        if std:
            vals = list(map(lambda v: v[0], values))
            errs = list(map(lambda v: v[1], values))
            plt.errorbar(x, vals, errs, label=label)
        else:
            plt.plot(x, values, label=label)

    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.title(title, wrap=True)

    if legend:
        plt.legend(loc='best')

    if len(filename):
        plt.savefig(filename)

    plt.clf()


def sort_threads():
    # sort on update matrix block
    sorted_threads = sorted(threads_list, key = lambda threads: int(threads.split('-')[2]))
    x_axis = list(map(lambda threads: int(threads.split('-')[2]), sorted_threads))
    return sorted_threads, x_axis


def generate_time_plot(size, block_size, filename):
    sorted_threads, x_axis = sort_threads()
    times = { "hedgehog": [], "openblas": [] }

    for threads, x in zip(sorted_threads, x_axis):
        hh_time = hh_measures[size][threads][block_size].mean()
        hh_std = hh_measures[size][threads][block_size].std()
        times["hedgehog"].append((hh_time, hh_std))
        lapack_time = lapack_measures[size][x].mean()
        lapack_std = lapack_measures[size][x].std()
        times["openblas"].append((lapack_time, lapack_std))

    create_plot(x_axis,
                times,
                "number of threads",
                "computation time (ms)",
                f"Computation time of Hedgehog's Cholesky and dpotrf (openblas) depending on the number of threads for a {size}x{size} matrix",
                legend=True,
                std=True,
                filename=filename)


def generate_speedup_plot(size, block_size, filename):
    sorted_threads, x_axis = sort_threads()
    speedups = []

    for threads, x in zip(sorted_threads, x_axis):
        hh_time = hh_measures[size][threads][block_size].mean()
        lapack_time = lapack_measures[size][x].mean()
        speedups.append(lapack_time / hh_time)

    create_plot(x_axis,
                { "speedup": speedups },
                "number of threads",
                "speedup",
                f"Speedup of Hedgehog's Cholesky against dpotrf (openblas) depending on the number of threads for a {size}x{size} matrix",
                legend=False,
                filename=filename)


def generate_relative_speedup_plot(size, block_size, filename):
    sorted_threads, x_axis = sort_threads()
    speedups = { "hedgehog": [], "openblas": [] }
    hh_one_thread_time = hh_measures[size][sorted_threads[0]][block_size].mean()
    lapack_one_thread_time = lapack_measures[size][x_axis[0]].mean()

    for threads, x in zip(sorted_threads, x_axis):
        hh_time = hh_measures[size][threads][block_size].mean()
        lapack_time = lapack_measures[size][x].mean()
        speedups["hedgehog"].append(hh_one_thread_time / hh_time)
        speedups["openblas"].append(lapack_one_thread_time / lapack_time)

    create_plot(x_axis,
                speedups,
                "number of threads",
                "speedup",
                f"Relative speedup of Hedgehog's Cholesky and dpotrf (openblas) depending on the number of threads for a {size}x{size} matrix",
                legend=True,
                filename=filename)


################################################################################
#                                    script                                    #
################################################################################

parse_results_hh("./results-hh-10000")
parse_results_lapack("../../cholesky-one-thread/scripts/results")
generate_hh_report("repport.md")
generate_speedup_plot(10000, 256, "speedup10000.pdf")
generate_time_plot(10000, 256, "times10000.pdf")
generate_relative_speedup_plot(10000, 256, "relative-speedup10000.pdf")
